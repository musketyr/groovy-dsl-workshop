= Groovy DSL Workshop
Vladimír Oraný <https://github.com/musketyr[icon:github[] @musketyr]>

== Getting Started

In this workshop we will learn how to create domain specific languages (DSL) in Groovy.
We will create builder-pattern style DSL with nested blocks which perfectly suits the Groovy language.

> The builder pattern is used to create complex objects with constituent parts that must be created in the same order or using a specific algorithm. An external class controls the construction algorithm. — The Gang of Four

We will use https://yuml.me/[yUML diagrams] (data class diagrams) as a reference domain model.

image:yuml-diagram.png[yUML Diagram's Model]

This workshop is based on **Groovy DSL Builders** series which can be used as reference documentation:

1. https://medium.com/p/2d5a97fa0a51[The Concept: The core concept of builders]
2. https://medium.com/p/fda1f2ebe657[The Essence: The closures' basics]
3. https://medium.com/p/df2e9a02557a[The Aid: Using the annotations for static compilation]
4. https://medium.com/p/1e2edc2311f8[The Disguise: Hiding the implementation of the builder API]
5. https://medium.com/p/afb47ebbf89d[The Desiccation: Keeping the code DRY]
6. https://medium.com/p/83ced4b8f2b[The Expectations: The importance of handling closures' owner properly]
7. https://medium.com/p/d612fd261471[The Extension: Designing your builder DSL for extendability]
8. https://medium.com/p/99bd118538b4[The Resignation: Rewriting the Groovy DSL builder into Java]
9. https://medium.com/p/d065f0253e98[The Navigation: Using the annotations for named parameters]
10. https://medium.com/p/9d2b961dbc55[The Conclusion: The checklist for Groovy DSL builders' authors]

=== Software Requirements

To get started you need to have installed following:

 * http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html[Java Development Kit 8]

Project is built using https://gradle.org/[Gradle] build tool but it's using https://docs.gradle.org/current/userguide/gradle_wrapper.html[Gradle Wrapper]
so you are not required to install it manually nor you don't have to be afraid of version clash.

You can use IDE of your choice but https://www.jetbrains.com/idea/[IntelliJ IDEA] provides so far the best
Gradle and Groovy integration even in the free Community version. Import the project as Gradle project get the best developer experience.

=== Project Archive

To get started download link:archives/groovy-dsl-workshop.zip[exercise project archive file] and unzip it. Run following command to get all dependencies downloaded:

```
./gradlew dependencies
```

You can execute tests by running following command:

```
./gradlew test
```

This will execute all the tests. There are several sub-projects called `step-xx` in the archive where `xx` is number
of the exercise. Each of exercises is covered by single test which will signal you that you have successfully finished
all the tasks. Each sub-project contains ideal solution of the previous exercise so in case of you get stuck or
you want to skip an exercise you get everything you need to keep coding. If you want to carry over your code
just delete everything in `src/main` directory and replace it with the content of `src/main` directory of of your previously finished step.

== Introduction

During this workshop, you are going to create DSL for https://yuml.me/[yUML.me] diagrams.
yUML helps to create simple UML diagram online. Its simplified data model is shown in the following diagram.

.YUML Diagram's Model
image:yuml-diagram.png[yUML Diagram's Model]


Although we are implementing Groovy DSL most of the DSL code will be written in Java. This approach will help you
to reach greater audience and help us avoid some common pitfalls more easily. See https://medium.com/p/99bd118538b4[The Resignation: Rewriting the Groovy DSL builder into Java]
for further reference on writing Groovy DSLs in Java.

First, we should get familiar with the data model in `cz.orany.yuml.model` package.

`Diagram` represents the diagram which can contain notes, types and their relationships.

[source,java,indent=0,options="nowrap"]
.Diagram.java
----
include::../step-00/src/main/java/cz/orany/yuml/model/Diagram.java[]
----

`Note` is a simple box placed next to the diagram which can have it's `text` and `color`.

[source,java,indent=0,options="nowrap"]
.Note.java
----
include::../step-01/src/main/java/cz/orany/yuml/model/Note.java[]
----

`Relationship` represents relationship between two types. Each relationship has
it's `type`, `source` and `destination`. Relationships can be `bidirectional`. You can specify
cardinality and title for the `source` and `destination`

[source,java,indent=0,options="nowrap"]
.Relationship.java
----
include::../step-01/src/main/java/cz/orany/yuml/model/Relationship.java[]
----

[source,java,indent=0,options="nowrap"]
.RelationshipType.java
----
include::../step-01/src/main/java/cz/orany/yuml/model/RelationshipType.java[]
----

`Type` is a data class determined by it's `name`.

[source,java,indent=0,options="nowrap"]
.Type.java
----
include::../step-01/src/main/java/cz/orany/yuml/model/Type.java[]
----

The very first iteration uses just map constructors to create the model. This state represents what you get for free in Groovy:

[source,groovy,indent=0,options="nowrap"]
.Creating Diagram using Constructors
----
include::../step-01/src/test/groovy/cz/orany/yuml/model/Diagram00Spec.groovy[tag=constructors]
----

The initial version is very verbose and there is definitely lot of place for the improvement in future steps.

== 1. Managing Diagram Content

The most of the verbosity of the initial example originates from manual handling
of diagram's content - relationships, notes and types. Let's make `Diagram` class responsible for managing these items.

[source,groovy,indent=0,options="nowrap"]
.Diagram Responsible for Content Management
----
include::../step-01/src/test/groovy/cz/orany/yuml/model/Diagram02Spec.groovy[tag=with]
----

Methods `note`, `type` and `relationship` are now responsible for creating or referencing the particular content of the diagram.
The example uses default Groovy method `with` simplify accessing diagram's parts properties. In the next step, we are going to
replace method `with` with our own implementation.

=== Tasks

1. Implement methods `note`, `type` and `relationship` in `Diagram` class to manage diagram content.
Methods must not create duplicates for the same input.
2. Make `Diagram02Spec.groovy` passing.

== 3. Closures

In this step we are going to replace calling `with` method with custom methods.

[source,groovy,indent=0,options="nowrap"]
.Methods Accepting Closures
----
include::../yuml/src/test/groovy/cz/orany/yuml/model/Diagram03Spec.groovy[tag=closures]
----

You can see there are many new methods accepting closures. They all simplifies calling the
base method `relationship` which can look like following one:

[source,groovy,indent=0,options="nowrap"]
.Methods Accepting Closures - Implementation
----
Relationship relationship(
    String source,
    RelationshipType relationshipType,
    String destination,
    @DelegatesTo(                                                                       // <1>
        value = Relationship,
        strategy = Closure.DELEGATE_FIRST
    )
    Closure additionalProperties = Closure.IDENTITY
) {
    Relationship relationship = new Relationship(
        type(source),
        relationshipType,
        type(destination)
    )
    relationship.with additionalProperties                                              // <2>
    this.relationships.add(relationship)
    return relationship
}
----
<1> To give the static compiler and IDE hint we need to use the annotation `@DelegatesTo` to specify which
type will be used as a delegate of the closure. The delegate is a primary/secondary/only receiver
of the method calls within the closure definition.
<2> Calling the closure can be still delegated to method `with` which does exactly what we need

Inheritance in the initial example is handled using a fluent DSL. Fluent DSL uses a feature called http://docs.groovy-lang.org/docs/latest/html/documentation/core-domain-specific-languages.html#_command_chains[Command Chains]
which allows to skip the parentheses.

`inherits` is just a regular method of `Type`.

[source,groovy,indent=0,options="nowrap"]
.Method `inherits`
----
InheritanceBuilder inherits(From from) {
    return new InheritanceBuilder(diagram, this)
}
----

`InheritanceBuilder` is a helper class to specify the rest of the information.`From` is just an enum
returned from `Diagram.getFrom()` static method.

[source,groovy,indent=0,options="nowrap"]
.Class `InheritanceBuilder`
----
@CompileStatic
class InheritanceBuilder {

    private final Type source
    private final Diagram diagram


    InheritanceBuilder(Diagram diagram, Type destination) {
        this.source = destination
        this.diagram = diagram
    }

    Relationship type(String destination) {
        return diagram.inheritance(source.name, destination)
    }
}
----

Here is another example of Fluent DSL to specify the cardinality of the items:

[source,groovy,indent=0,options="nowrap"]
.Fluent DSL
----
include::../yuml/src/test/groovy/cz/orany/yuml/model/Diagram03Spec.groovy[tag=fluent]
----

=== Tasks
1. Implement method accepting closures for building relationships
2. Implement method accepting closures as shortcuts for each relationship type
3. Implement fluent DSL for describing inheritance
4. Implement fluent DSL for describing cardinality and title
5. Make `Diagram03Spec` passing

== 4. API Extraction

Well-crafted DSL should only expose as many feature as required. At this step, your `Diagram`
class should expose methods for adding new parts of the diagram as well as the accessors methods.

Let's split the API into two separate categories, each described using Java interfaces.

1. API for reading diagram's content
2. API for creating diagram's content

`Diagram` interface will only contain methods to access the content of the diagram:

[source,java,indent=0,options="nowrap"]
.Diagram.java
----
public interface Diagram {

    static Diagram build(@DelegatesTo(value = DiagramDefinition.class, strategy = Closure.DELEGATE_FIRST) Closure definition) {
        return DefaultDiagramFactory.build(definition);
    }

    Collection<? extends Note> getNotes();
    Collection<? extends Type> getTypes();
    Collection<? extends Relationship> getRelationships();

}
----

`DiagramDefinition` will only contain methods for building the diagram's content

[source,java,indent=0,options="nowrap"]
.DiagramDefintion.java
----
public interface DiagramDefinition {

    static From getFrom() {
        return From.FROM;
    }

    static Integer getZero() {
        return 0;
    }

    static Integer getOne() {
        return 1;
    }

    static String getMany() {
        return "*";
    }

    default Note note(String text) {
        return note(text, null);
    }

    Note note(String text, String color);

    default TypeDefinition type(String name) {
        return type(name, Closure.IDENTITY);
    }

    TypeDefinition type(String name, @DelegatesTo(value = TypeDefinition.class, strategy = Closure.DELEGATE_FIRST) Closure builder);

    default RelationshipDefinition aggregation(String source, String destination) {
        return aggregation(source, destination, Closure.IDENTITY);
    }

    default RelationshipDefinition aggregation(
        String source,
        String destination,
        @DelegatesTo(value = RelationshipDefinition.class, strategy = Closure.DELEGATE_FIRST) Closure additionalProperties
    ) {
        return relationship(source, RelationshipType.AGGREGATION, destination, additionalProperties);
    }

    default RelationshipDefinition composition(String source, String destination) {
        return composition(source, destination, Closure.IDENTITY);
    }

    default RelationshipDefinition composition(
        String source,
        String destination,
        @DelegatesTo(value = RelationshipDefinition.class, strategy = Closure.DELEGATE_FIRST) Closure additionalProperties
    ) {
        return relationship(source, RelationshipType.COMPOSITION, destination, additionalProperties);
    }

    default RelationshipDefinition inheritance(
        String source,
        String destination
    ) {
        return inheritance(source, destination, Closure.IDENTITY);
    }

    default RelationshipDefinition inheritance(
        String source,
        String destination,
        @DelegatesTo(value = RelationshipDefinition.class, strategy = Closure.DELEGATE_FIRST) Closure additionalProperties
    ) {
        return relationship(source, RelationshipType.INHERITANCE, destination, additionalProperties);
    }

    default RelationshipDefinition association(String source, String destination) {
        return association(source, destination, Closure.IDENTITY);
    }

    default RelationshipDefinition association(
        String source,
        String destination,
        @DelegatesTo(value = RelationshipDefinition.class, strategy = Closure.DELEGATE_FIRST) Closure additionalProperties
    ) {
        return relationship(source, RelationshipType.ASSOCIATION, destination, additionalProperties);
    }

    default RelationshipDefinition relationship(String source, RelationshipType relationshipType, String destination) {
        return relationship(source, relationshipType, destination, Closure.IDENTITY);
    }

    RelationshipDefinition relationship(
        String source,
        RelationshipType relationshipType,
        String destination,
        @DelegatesTo(value = RelationshipDefinition.class, strategy = Closure.DELEGATE_FIRST) Closure additionalProperties
    );

}
----

You can see we are fully leveraging features added in Java 8 such as static and default methods in interfaces.
Thanks to these features the implementation is pretty minimal:

[source,java,indent=0,options="nowrap"]
.DefaultDiagram.groovy
----
class DefaultDiagram implements Diagram, DiagramDefinition {

    final Collection<DefaultNote> notes = new LinkedHashSet<>()
    final Collection<DefaultRelationship> relationships = new LinkedHashSet<>()

    private final Map<String, DefaultType> typesMap = [:].withDefault { key -> new DefaultType(this, key.toString()) }

    @Override
    Collection<? extends Type> getTypes() {
        return typesMap.values()
    }

    @Override
    DefaultNote note(String text, String color) {
        Note note = new DefaultNote(text, color)
        this.notes.add(note)
        return note
    }

    @Override
    DefaultType type(String name, @DelegatesTo(value = TypeDefinition, strategy = Closure.DELEGATE_FIRST) Closure builder) {
        DefaultType type = typesMap[name]
        type.with builder
        return type
    }

    @Override
    DefaultRelationship relationship(
        String source,
        RelationshipType relationshipType,
        String destination,
        @DelegatesTo(value = RelationshipDefinition, strategy = Closure.DELEGATE_FIRST) Closure additionalProperties
    ) {
        DefaultRelationship relationship = new DefaultRelationship(type(source, Closure.IDENTITY), relationshipType, type(destination, Closure.IDENTITY))
        relationship.with additionalProperties
        this.relationships.add(relationship)
        return relationship
    }

}
----

=== Tasks
1. Extract content (accessors) API from the current `Diagram`, `Relationship`, `Type` classes into interfaces of he same name
2. Extract builder API from the current `Diagram`, `Relationship`, `Type` classes into into interfaces ending `Definition`
3. Put the implementation into classes with `Default` prefix
4. Make `Diagram04Spec` passing

== 5. Closures with Parameters

So far the diagrams were described in a single long method following the code-as-data principle.
In many situations we want to keep our code DRY ("do not repeat yourself").

[source,groovy,indent=0,options="nowrap"]
.Keeping DSL DRY
----
include::../yuml/src/test/groovy/cz/orany/yuml/model/Diagram05Spec.groovy[tag=dry]
----
<1> Send the delegate of the closure  as a parameter of the closure helps you breaking the DSL definition into smaller chunks
<2> Using default method `with` helps you to _continue_ using the DSL even in the extracted method

You need to use `@ClosureParams` annotation to help the static compiler and IDE keep track of the closure's parameters.

[source,java,indent=0,options="nowrap"]
.Diagram.java
----
TypeDefinition type(
    String name,
    @DelegatesTo(value = TypeDefinition.class, strategy = Closure.DELEGATE_FIRST)
    @ClosureParams(value = SimpleType.class, options = "cz.orany.yuml.model.dsl.TypeDefinition")
    Closure<? extends DiagramContentDefinition> builder
);
----

TIP: You don't need to update the implementation classes if they still use `with` method internally
as `with` method is already sending self as a single parameter to the closure.

=== Tasks
1. Add `@ClosureParams` annotations to the methods accepting closures and ensure the definition object is passed into the closure as a single parameter.
2. Make `Diagram05Spec` passing

== 6. Closure Pitfalls

There are some common misunderstandings when we use closures, especially when the closures are nested one into another.

Let's take a look on a typical example of nested closures. Assume that all the methods set the resolution strategy to
`DELEGATE_FIRST`

[source,groovy,indent=0,options="nowrap"]
.Nested Closures
----
    String someProperty = 'Some Property Content'                                       // <1>

    void doBuild() {
        new SomeBuilder().levelOne {                                                    // <2>
            levelTwo {                                                                  // <3>
                something = someProperty                                                // <4>
            }
        }
    }
----
<1> A class has a property which we would like to access from the nested closure
<2> First closure definition - the closure's `owner` is instance of our class
<3> Second closure definition - the closure's `owner` is the surrounding closure
<4> One would expect that `someProperty` is the `someProperty` we declared in our class but as the `owner` of the
closure is the surrounding closure with its own complicated property handling we might be actually reading property
`someProperty` of the delegate of the surrounding closure.

To workaround this problem we need to manually keep track of the `owner` of the top level closure. We can achieve this
by updating the `DefaultDiagram` class to also hold the `owner`.

[source,groovy,indent=0,options="nowrap"]
.Creating Diagram using Constructors
----
class DefaultDiagram implements Diagram, DiagramDefinition {

    private final Object owner;

    // other fields

    DefaultDiagram(Object owner) {                                                      // <1>
        this.owner = owner
    }

    // other methods

    @Override
    DefaultType type(
        String name,
        @DelegatesTo(
            value = TypeDefinition.class,
            strategy = Closure.DELEGATE_FIRST
        )
        @ClosureParams(
            value = SimpleType.class,
            options = "cz.orany.yuml.model.dsl.TypeDefinition"
        )
        Closure<? extends DiagramContentDefinition> builder
    ) {
        DefaultType type = typesMap[name]
        withSameOwner type, builder                                                     // <2>
        return type
    }

    protected <V, T> V withSameOwner(T self, Closure<V> closure) {
        final Closure<V> clonedClosure = closure.rehydrate(                             // <3>
            self,
            owner,
            closure.thisObject
        )
        clonedClosure.setResolveStrategy(Closure.DELEGATE_FIRST);
        clonedClosure.call(self)
    }
}
----
<1> The `DefaultDiagram` now must be constructed with the reference to the surrounding closure's `owner`
<2> We no longer use default `with` method but slightly updated one which also replaces the `owner` with expected one
<3> We use closure's method `rehydrate` to create a clone with expected `owner`

=== Tasks
1. Make sure all method accepting closures properly handles the owner
2. Make `Diagram06Spec` passing

== 7. Providing Extension Points

A good DSL provides an extension points which allows the developers to extend the language. In our yUML example some
developers might want to add attribute definitions to the types or declare types as stereotypes.

[source,groovy,indent=0,options="nowrap"]
.Extensions
----
include::../yuml/src/test/groovy/cz/orany/yuml/model/Diagram07Spec.groovy[tag=extensions]
----
<1> Stereotype declaration
<2> Property declaration

The easiest way how to start extending any DSL is using Groovy's extension classes. Extension classes contains
static methods which first argument is of the type we want to extend.

For example `stereotype` can be easily handled by calling `type` with the name surrounded by `<<` and `>>`.

[source,groovy,indent=0,options="nowrap"]
.Stereoptypes Extension
----
public class StereotypeExtensions {

    public static TypeDefinition stereotype(
        DiagramDefinition diagram,
        String name
    ) {
        return diagram.type("<<" + name + ">>");
    }

    // other extension methods

}
----

To enable the class as extension module you need to create a file `META-INF/services/org.codehaus.groovy.runtime.ExtensionModule` with the following content:

.Extensions Declaration
----
moduleName=yuml-extra
moduleVersion=0.1.0
extensionClasses=cz.orany.yuml.stereotype.StereotypeExtensions
staticExtensionClasses=
----

For more complicated extensions we can introduce some generic container such as `Map<String, Object> metadata`
into the diagram class which we can manipulate using _helper_ objects:

[source,java,indent=0,options="nowrap"]
.Metadata Helpers
----
@Override
public <H extends DiagramHelper, R> H configure(
    @DelegatesTo.Target("helper")
    Class<H> helper,
    @DelegatesTo(
        value = DelegatesTo.Target.class,
        target = "helper",
        strategy = Closure.DELEGATE_FIRST,
        genericTypeIndex = 0
    )
    @ClosureParams(FirstParam.FirstGenericType.class)
    Closure<R> configuration
) {
    H helperInstance = (H) helperMap.computeIfAbsent(helper, {
        helper.newInstance()
    })
    DefaultGroovyMethods.with(helperInstance, configuration)
    return helperInstance
}

void postprocess() {
    for (DiagramHelper helper : helperMap.values()) {
        metadata.putAll(helper.metadata)
    }
}
----

We can use these helpers in another extension class to store the properties:

[source,groovy,indent=0,options="nowrap"]
.Properties Extension
----
CompileStatic
class PropertiesDiagramHelperExtensions {

    static TypeDefinition property(
        TypeDefinition typeDefinition,
        String type,
        String name
    ) {
        typeDefinition
            .diagramDefinition
            .configure(PropertiesDiagramHelper) {
                it.addProperty(typeDefinition.name, type, name)
            }
        return typeDefinition
    }

    static TypeDefinition property(
        TypeDefinition typeDefinition,
        Map<String, String> properties
    ) {
        typeDefinition
            .diagramDefinition
            .configure(PropertiesDiagramHelper) {
            it.addProperties(typeDefinition.name, properties)
        }
        return typeDefinition
    }
}
----

=== Tasks
1. Create extension to support `stereotype`
2. Create extension to support `properties`
3. Make `Diagram07Spec` passing

== 8. Java DSL

As DSL creator, you will probably want to reach the widest audience possible. Plain old Java is still
far more popular then Groovy. Rewriting your DSL into Java will help you to attract more developers who don't want or
simply can't use Groovy as their primary language.

Java 8 supports lambda expression which looks quite similar to Groovy closures but it lacks the ablity
to alter the delegate. `Consumer`interface can be easily used instead of closures for most of the
situations.

[source,java,indent=0,options="nowrap"]
.Diagram08Test.java
----
include::../yuml/src/test/groovy/cz/orany/yuml/model/Diagram08Test.java[tag=java]
----

The significant difference is the presence of the callee as `Diagram d` which is passed inside the lambda
body.

I consider a good practise to keep the Groovy code separated inside extension methods which will look like
the original ones except the accept the original type as a first argument:

[source,java,indent=0,options="nowrap"]
.Extension method inside DiagramExtensions.java
----
public static RelationshipDefinition relationship(
    DiagramDefinition self,
    String source,
    RelationshipType relationshipType,
    String destination,
    @DelegatesTo(
        value = RelationshipDefinition.class,
        strategy = Closure.DELEGATE_FIRST
    )
    @ClosureParams(
        value = SimpleType.class,
        options = "cz.orany.yuml.model.dsl.RelationshipDefinition"
    )
    Closure<? extends DiagramContentDefinition> additionalProperties
) {
    return self.relationship(
        source,
        relationshipType,
        destination,
        ConsumerWithDelegate.create(additionalProperties)
    );
}
----

`ConsumerWithDelegate` comes from Groovy Closure Support library which provides couple of
helper wrappers for closures and popular `java.util.function.` types.

=== Tasks
1. Rewrite your DSL into Java
2. Make `Diagram08Spec` and `Diagram08Test` passing

== 9. Named Arguments

== Solutions

You can find reference solutions https://github.com/musketyr/yuml-dsl-builder/releases[here].
